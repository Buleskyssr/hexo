---
title: 面试基础知识
date: 2023-02-2 17:00:00
tags: 面试
mathjax: true
---

# 面试基础知识

## 时间复杂度

> 内容参考《数据结构与算法分析》
>
> test2

### 定义

- 定义1 如果存在正常数$c$和$n_0$使得当$N\geq n_0$时$T(N)\leq cf(N)$，记为$T(N)=O(f(N))$
- 定义2 如果存在正常数$c$和$n_0$使得当$N\geq n_0$时$T(N)\geq cg(N)$，记为$T(N)=\Omega(g(N))$
- 定义3 $T(N)=\Theta(h(N))$ 当且仅当 $T(N)=O(h(N))$和$T(N)=\Omega(h(N))$
- 定义4 如果对于每一个正常数$c$都存在常数$n_0$使得当$N>n_0$时$T(N)<cp(N)$，则$T(N)=o(p(N))$

<!--more-->

其实对于上述的四个定义，主要是在比较不同算法间的一个**相对增长率**，而且主要比较的当$N$趋于无限大的时候，因为我们一般程序在规模较小的时候比较时间开销其实并没有什么必要，重要的是当规模增大时，对算法的时间开销进行一个比较。

例如定义1，$O()$，又叫**大O标记法**，主要考虑的是我们算法的时间复杂度的**上界**，即我们是在保证算法$T(N)$是在以不快于$f(N)$的速度增长。同理，定义二就是不低于$g(N)$的速度增长，而定义三就是说明$T(N)$和$h(N)$的增长速度相同

我们需要知道以下的结论：

1. 如果$T_1(N)=O(f(N))$ 且$T_2(N)=O(g(N))$，那么
   1. $T_1(N)+T_2(N)=O(f(N)+g(N))$或者可以写成$max(O(f(N)),O(g(N)))$
   2. $T_1(N)*T_2(N)=O(f(N)*g(N))$
2. 如果$T(N)$是一个$k$次多项式，则$T(N)=\Theta(N^k)$
3. 对于任意常数$k$，$log^kN=O(N)$。这说明**对数增长得非常缓慢**

典型的增长率：
$$
c<logN<log^2N<N<NlogN<N^2<N^3<2^N
$$
我们拿**最大子序列问题**来比较不同算法的时间复杂度：

### 最大子序列问题

```java
有一个序列 {4,-3,5,-2,-1,2,6,-2}
求子序列中和最大
可以看到子序列和最大为 4-3+5-2-1+2+6=11
输出子序列最大的和：11
```

我们这边介绍四种算法：

#### 穷举

```java
static int algorithm1(int[] input) {
        int len = input.length;
        int maxSum = 0;

        for (int i = 0; i < len; i++) {
            for (int j = i; j < len; j++) {
                int tempSum = 0;
                for (int k = i; k <= j; k++) {
                    tempSum += input[k];
                }
                if(tempSum>maxSum){
                    maxSum = tempSum;
                }
            }
        }
        return maxSum;
    }
```

 可以看到有三个嵌套的`for` 循环，所以很明显，时间复杂度就是$O(N^3)$

#### 改进穷举法

```java
static int algorithm2(int[] input) {
        int len = input.length;
        int maxSum = 0;

        for (int i = 0; i < len; i++) {
            int tempSum = 0;
            for (int j = i; j < len; j++) {
                tempSum += input[j];
                if (tempSum > maxSum) {
                    maxSum = tempSum;
                }
            }
        }

        return maxSum;
    }
```

该改进算法只是单纯删减了算法一中计算`tempSum`的过于复杂的操作，也只是减少了一个循环，时间复杂度为$O(N^2)$，还是很大

#### 分治法

```java
static int algorithm3(int[] input,int left, int right){

    //Base case
    if(left==right){
        if(input[left]>0){
            return input[left];
        }
        else {
            return 0;
        }
    }

    int center = (left+right)/2;
    int maxLeftSubSum = algorithm3(input,left,center);
    int maxRightSubSum = algorithm3(input, center+1, right);

    //calculate the sum of sequence starting from border
    int maxLeftBorderSum = 0, leftBorderSum = 0;
    for(int i=center;i>=left;i--){
        leftBorderSum+=input[i];
        if(leftBorderSum>maxLeftBorderSum){
            maxLeftBorderSum = leftBorderSum;
        }
    }

    int maxRightBorderSum = 0, rightBorderSum = 0;
    for(int i=center+1;i<=right;i++){
        rightBorderSum+=input[i];
        if(rightBorderSum>maxRightBorderSum){
            maxRightBorderSum = rightBorderSum;
        }
    }
    int maxBorderSum = maxLeftBorderSum+maxRightBorderSum;

    return max3(maxLeftSubSum,maxRightSubSum,maxBorderSum);

}

private static int max3(int a, int b, int c) {
    int temp = Math.max(a,b);
    return Math.max(c,temp);
}
```

分治法其实核心思想就是“分而治之”，即将一个大问题划分为多个大小差不多的子问题，然后递归对他们求解（需要明确`Base Case`），这就是”分“， 然后多个子问题的解补在一起就可以得到最终的解，也就是“治”。

求解最大子序列问题，我们可以把问题拆分成三种情况：

1. 最大子序列在整个序列的左半部分
2. 最大子序列在整个序列的右半部分
3. 最大子序列横跨序列中间

对于第一第二种情况，直接调用递归，第三种情况我们从中间向两边扩散，求到最大的和即可。

我们对于时间复杂度可以得到：
$$
<p>
    <span class="math display">
        \(T(1)=1 \)</br>
        \(T(N)=2T(N/2)+O(N)\)</br>
    </span>
</p>
$$

$$
T(1)=1 \\\\
T(N)=2T(N/2)+O(N)  
$$

$O(N)$ 即代码中**18~33**中求解`maxBorderSum`的过程

我们可以发现 :
$$
T(2)=4=2*2,T(4)=12=4*3,T(8)=32=8*4
$$


推理得到，当 $N=2^k$时，$T(N)=N*(k+1)=NlogN+N=O(NlogN)$

当然，这是当$N$为偶数的情况，实际上当奇数的时候虽然并不是这么计算，但是也只是会多一些复杂的计算，大$O$的计算结果并不会变。

#### 巧解

```java
static int algorithm4(int[] input){
        int len = input.length;
        int maxSum = 0;
        int tempSum = 0;

        for(int i=0;i<len;i++){
            tempSum+=input[i];
            if(tempSum>maxSum){
                maxSum = tempSum;
            }
            else if(tempSum<0){
                tempSum=0;
            }
        }
        return maxSum;
    }
```

我们可以看到该算法的时间复杂度为惊人的$O(N)$, 线性复杂度，远远优于上面的三个算法。

该算法巧妙的发现，累和为负的子序列必然不可能是最大子序列，所以只用一次遍历，当`tempSum`为负的时候，直接赋值0，即完全抛弃前面的子序列对后面子序列的影响。

